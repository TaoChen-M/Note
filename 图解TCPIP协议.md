# 图解TCP协议

## 传输层基础知识

传输层通过**端口号**来区分将当前数据传递给应用层的哪一个应用程序

因此，为了处理客户端可能的请求，服务端的程序有必要提前启动，这些服务端程序在UNIX系统中叫做守护进程，实际上服务端会启动一个互联网超级守护进程，这些进程在受到请求后，根据请求的类别，如（http或者ssh等）启动新的进程，并将这些进程转换为对应的守护进程

![](/images/传输层信息传输基础.png)

## UDP协议详解

UDP是面向**无连接**的协议，不保证传输的可靠性，其只是将应用层的数据原样不动的发送到网络上，经常用于以下几个方面：

- 包总量较少的通信：DNS、SNMP
- 视频、音频等多媒体通信
- 广播通信

## TCP协议详解

TCP是面向连接的、可靠的传输协议，为了提供可靠的传输功能，实行“顺序控制”、“重发控制”的句机制，并且具有“拥塞控制”、“流量控制”的功能，主要应用在以下几个方面

- FTP文件传输
- HTTP/HTTPS通信

### TCP首部格式

![](/images/TCP首部.png)

源端口号：表示发送端端口号

目标端口号：接收端端口号

序列号：TCP是面向字节流的协议，其一次传输的字节流中的每个字节都会分配一个序号，序列号值是本次发送的报文段的第一个字节的序号

确认应答号：指下一次应该收到的数据的序列号，发送端收到这个确认应答就会知道这个序号之前的数据都已经被正常接收

控制位

![](/images/控制位.png)

- ACK：该位为1，表明确认应答字段有效，除了最初建立连接时的报文之外，该位一般都是1
- SYN：用于建立连接，SYN为1表明希望建立连接
- FIN：通信结束希望断开连接，双方可以发送FIN位置为1的TCP段

### 三次握手建立连接

![](/images/三次握手.png)

客户端随机初始化序列号，并且将控制位中SYN置为1，表示希望建立连接

服务端收到报文之后，也随机初始化自己的序列号，同时将客户端的序列号+1放入确认应答号，把控制位中SYN和ACK位置为1，发送给客户端

客户端收到服务端的确认应答之后，也发送一个确认应答报文给服务端，至此双方连接完成。**在第三次握手时，是可以携带数据的**

#### 如何在Linux中查看TCP状态

`netstat -napt`命令

![](/images/netstat命令.png)

#### 为什么是三次握手，不是两次或者四次？

两次握手无法确保服务端的回应是最新的请求连接回应报文

因为网络延迟等原因，先发送的连接请求迟迟没有回应，客户端会发送一个新的连接请求，但是旧的连接请求可能会早一步到达服务端，此时服务端回发一个SYN+ACK报文，那么具有第三次连接的客户端就可以根据ACK中的内容确定这个应答报文是不是历史连接的应答报文，如果是则会发送一个RST报文给服务端，中止这一次连接

同步双方的初始序列号

客户端发送携带初始序列号的SYN报文时，需要服务端回一个ACK报文，表示客户端的SYN报文已经被成功接收，那么当服务端发送初始序列号给客户端时，也要得到客户端一个应答，这样一来一回，可以确保双方的初始序列号已经被同步。而服务端在发送初始序列号和应答客户端的ACK报文，可以合并为1步

#### 什么是SYN攻击？如何避免？

短时间内伪造大量的不同IP地址的请求连接报文，因为每接收到一个请求连接报文，服务端就要回发一个ACK+SYN报文，但是这些报文全都没有收到应答，久而久之就会占满服务端的SYN接收队列

解决方式：修改linux内核参数，控制队列大小和当队列满时直接回报RST报文

### TCP四次握手断开连接

![](/images/四次握手.png)

客户端打算断开连接，发送一个FIN报文给服务端，之后进入等待状态

服务的端收到后，发送一个ACK应答报文，随后进入等待状态，但是依然可以继续处理数据

客户端收到服务端的应答ACK报文之后，进入另外一种等待状态

服务端处理完成数据之后，向客户端发送FIN报文，随后进入最后的等待确认状态

客户端收到FIN报文后，回一个ACK应答报文，之后便进入了TIME_WAIT状态

服务端收到客户端的ACK报文后，就进入GLOSED状态。至此服务端已经完成连接的关闭

客户端在经过2MSL一段时间后，自动进入CLOSED状态，至此客户端也完成连接的关闭

#### 为什么挥手需要四次？

双发发送FIN报文的过程：

- 关闭连接，客户端向服务端发送FIN报文之后，仅仅表示客户端不会再发送数据，但是依然可以继续接收数据
- 服务端在收到客户端的FIN报文之后，先发送一个ACK报文，但是之后还会继续处理数据，只有这些数据全部处理完成之后，才会发送一个FIN报文来表示同意最终的关闭连接

从上述过程可以看出，同三次握手相比，服务端收到客户端的请求连接之后，即发送ACK报文同时发送SYN连接请求报文相比，断开连接的情况下，服务端发送完ACK报文之后，还有数据需要处理，只有当这些数据处理完成之后，才会发送FIN报文

![](/images/连接建立与断开.png)

#### 为什么有TIME_WAIT状态？

- 防止旧链接的数据包
- 确保被动连接的一方能够被正确的关闭，即保证最后的ACK报文能能够被正确接收到

#### 防止旧的连接数据包被接收

![](/images/旧连接数据包.png)

在传输过程中假设有一个数据包延迟了，但是客户端和服务端已经完成断开连接。此时如果有一个具有相同端口号的TCP连接建立，那么这个被延迟的数据包就会被接收，但是其是属于上一次连接的，这样就会造成数据混乱。而2MSL这个时间足以让网络上两个方向上的没有被接收的数据包全部被丢弃

#### 保证连接正确关闭

![](/images/确保正确关闭.png)

如果传输过程客户端的应答ACK报文丢失，并且客户端没有2MSL的等待时间，那么服务端就会一直处于等待状态，如果具有2MSL的等待状态，服务端就可以重发一个FIN报文，客户端接收到并作出应答

#### 如果TIME_WAIT过多会有什么危害？

如果服务器有TIME_WAIT说明是服务器主动进行的关闭，过多的TIME_WAIT一般有两种：

- 第一是内存占用
- 第二是对端口资源的占用，一个TCP连接至少占用一个本地端口

可以使用的端口数量总共就是65536个，所有的端口都被占用了，就无法建立新的连接

### 超时重传

在TCP中，发送端的数据到达目标主机时，接收端主机会发送一个确认应答消息，表示自己收到了消息

![](/images/消息确认.png)

但是数据在网络上传送的时候，可能发送方传递的消息丢失了，或者接收方的应答报文丢失了，发送方在设定的时间内收不到ACK应答报文，发送方就会重新发送数据

![](/images/超时重传.png)

在BSD的UNIX和Windows系统中，重发超时都是0.5s的整数倍，因为最初的数据不知道往返时间，时间一般设置为6s，数据被重发之后，如果还没有收到确认应答，则会再次进行发送，等待时间以2倍4倍的指数增长，当数据被重发到一定次数之后，就会强制关闭连接

#### 快速重传

超时重传是以时间为标准，快速重传以数据为驱动

![](/images/快速重传.png)

以上图为例，第一份Seq1先传送到了，于是ACK回发一个2，但是后续的数据Seq2在传送过程中丢失了，即使后续的Seq3、Seq4、Seq5收到了，ACK回的依然是2，于是发送端根据多个相同的ACK应答报文，会在定时器结束之前重传这份丢失的报文

### 滑动窗口

TCP发送数据时以段为单位进行发送，这里的段指的是最大消息长度MSS（IP中不会被分片处理的最大数据长度），每发一个段就要进行确认应答的处理，这样一来，如果包的往返时间越长通信性能就越低

因此，TCP引入窗口这一概念，窗口大小指的是无需等待确认应答，可以连续发送数据的最大值

窗口实际是操作系统开辟的一段缓存区间，发送方在收到确认应答之前，会一直保留这些数据，否则删除

假设窗口大小是3个TCP段，即使有某一个段的ACK确认应答没有收到，那么也可以通过之后的确认应答来确认之前的报文已经收到

![](/images/下一个确认应答.png)

即使600的ACK报文丢失，但是通过700的ACK报文可以知道600的已经被接收到了

#### 窗口大小是由哪一方决定的

通常会在发送方和接收方的缓存窗口中选择较小的那一个

## 流量控制

在客户端向服务端发送数据的时候，如果此时服务端此时处于非常忙碌的状态，无法接收数据，如果接收端将本该接收的数据丢弃的话，又会触发重发机制，这样就会导致网络流量的无端浪费，TCP提供一种机制就是让发送端根据接收端的实际接收能力控制发送的数据量

TCP首部中有一个字段用来通知窗口大小，接收端可以将自己的接收缓冲区大小放入这个字段中发送给发送端，这个字段的值越大说明网络的吞吐量越大。这样发送端就可以根据接收端的指示来对数据的发送量进行控制

![](/images/流控制.png)

## 拥塞控制

流量控制是为了防止发送方的数据填满接收方的缓存，拥塞窗口是为了防止网络出现拥堵的时候，发送方还在持续不断地发送数据

拥塞窗口cwnd是发送方维持的一个变量，会根据网络的拥堵情况实时变化，之前的发送窗口swnd和接收窗口rwnd是约等于的关系，在加入了拥塞窗口之后，swnd=min(cwnd，rwnd)

拥塞窗口的变化规则：网络没有出现拥堵，窗口增大；网络出现拥堵，窗口减小

**如何确定网络出现了拥塞？**只要发生了超时重传，就认为出现拥塞

### 慢启动

TCP在刚刚建立连接的时候，有一个慢启动的过程，也就是一点一点的提高发送数据包的量，最开始的时候拥塞窗口的大小是一个MSS段的长度，每当发送端收到一个ACK应答报文，就会将窗口增大1

![](/images/慢启动.png)

慢启动会有一个门限，当窗口大小小于这个阈值的时候一直是指数增长，当达到这个阈值的时候，就会使用拥塞避免算法

### 拥塞避免算法

当拥塞窗口达到慢启动门限ssthresh时，就会进入拥塞避免算法，一般来说ssthresh是65535

拥塞避免算法规则是：每当收到一个ACK报文，cwnd窗口大小增加1/cwnd

例如ssthresh是8，那么收到8个ACK确认报文，每个增加1/8，最终窗口增加的总大小是1个MSS，将之前的指数增长变成线性增长

![](/images/拥塞避免.png)

当窗口再一直逐渐增大一直到网络出现拥塞，发生丢包现象，触发重传机制，也就进入了拥塞发生算法

### 拥塞发生

重传机制主要有超时重传和快速重传，两种的拥塞发生算法不同

#### 超时重传

- ssthresh变为cwnd/2
- cwnd重置为1
- 重新开始慢启动

![](/images/超时重传拥塞发生.png)

#### 快速重传

- ssthresh=cwndcwnd=cwnd/2，窗口大小变为原来的一半
- ssthresh等于减半之后的窗口大小
- 进入快速恢复算法

#### 快速恢复

快速恢复和快速重传一般同时使用，过程如下：

- 拥塞窗口cwnd=ssthresh+N（N是相同的ACK数据包数量）
- 重传丢失的数据包
- 如果ACK还是重复的，将cwnd+1
- 如果收到新的ACK报文，将cwnd设置为之前的ssthresh的值，恢复过程结束，再次进入拥塞避免状态

![](/images/快速恢复.png)

### 拥塞算法示意图

![](/images/拥塞算法示意图.png)