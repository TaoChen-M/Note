# 图解HTTP笔记

## OSI七层和TCP/IP四层模型

![](/images\截图.png)

### 为什么OSI要分为七层

1. 易于实现，各层相对独立，将大问题分割为各个小问题
2. 灵活性好，如果某一层发生了改变，只要接口不变，不会影响到其他层
3. 当前层不需要知道其他层是如何设计的，只需要调用接口来获得所需服务即可

## TCP/IP中数据发送过程

![](/images/数据发送过程.png)

## HTTP协议关系密切的三个协议

### IP协议

IP协议位于网络层，它的主要作用就是将各种数据包传送给对方，其需要两个重要的地址，一个是IP地址，另外一个是MAC地址，ARP协议负责将IP地址转换为MAC地址

IP在传送各种数据包的时候，并不是直接发送到目标主机上，而是通过路由中转，采用逐跳的方式确定通信路径

### TCP协议

TCP协议在传输层，提供字节流服务。它将上层的HTTP中的数据切割为一个个的报文段来方便传输，并且提供的是可靠传输。

在TCP建立连接之前，需要进行三次握手，三次握手过程中有一个非常重要的标志即SYN和ACK

![](/images/TCP三次握手.png)

### DNS服务

DNS是域名解析协议，负责将域名解析为IP地址。

### 各种协议和HTTP协议联合工作的过程（URL输入网址之后的过程）

![](/images/URL输入之后的过程.png)

## HTTP协议结构基础

HTTP是一种请求响应式协议，通信过程必须要有一个客户端和一个服务端，通过客户端发起请求，服务端进行响应。传输过程对消息内容进行压缩编码和分块传输。

![](/images/请求响应.png)

### 请求首部

![](/images/请求报头.png)

![](/images/请求首部.png)

起始行开头的GET和POST方法表示请求访问服务器的类型，叫方法。GET获取服务器的资源，POST向服务器发送信息

*GET和POST方法都是安全和幂等的吗？*

- *安全：在HTTP协议中，安全是指请求的方法不会破坏服务器上的资源*
- *幂等：多次执行相同的操作结果都是相同的*

- *GET方法是安全且幂等的，因为其是只读操作，POST方法是不安全且不幂等的*

紧接着的URI表示请求访问的资源对象

HOST是服务器域名，因为同一个服务器上使用虚拟主机的方式可能会部署多个域名，但是经过DNS解析之后，这些域名都指向同一个IP地址，因此用HOST来区分

HTTP/1.1，指明HTTP版本号

Connection字段：用来管理持久连接，HTTP/1.1版本默认都是持久连接，旧版本不是，需要指定该字段为Keep-alive，如果想要断开连接，指定为close

Accept字段：表明客户端可以接受的内容格式

Accept-Encoding字段：客户端支持的内容编码

Accept-Language字段：客户端能够处理的语言类型

### 响应报头

![](/images/响应报头.png)

HTTP/1.1表示服务器对应的HTTP版本

200 OK 是请求处理结果的状态码

### HTTP的无状态属性

http协议是无状态协议，不对之前的请求和响应进行保存。比如登录淘宝网址，如果不对登录的情况进行保存，每次跳转都要进行重新登录，这是非常麻烦的，但是如果让服务器记录每个客户端的状态，也不现实，不符合HTTP轻量化设计的初衷

**引用Cookie技术来保存状态，在请求和响应报文中写入Cookie信息**

初次客户端向服务端发送请求报文，服务端会在响应报文中添加一个Set-Cookie字段，设置Cookie值；客户端收到响应后，会保存这个Cookie值，并在下次请求报文中加上这个Cookie值，这样服务端就可以根据Cookie值来判断请求消息来自于那个客户端。对比服务器上的记录，得到之前的状态信息

![](/images/Cookie.png)

### 持久连接

在HTTP协议的最初版本中每进行一次HTTP的通信，就要进行一次的TCP连接和断开，增加通信量的开销

HTTP/1.1和部分HTTP/1.0支持持久连接，也称为Keep-alive方法，即一次TCP连接，多次进行HTTP的请求和响应，直到一端提出明确的断连

![](/images/持久化.png)

### 管线化技术

管线化技术是建立在持久连接基础之上的，以往客户端都是发送一个请求然后等待服务器响应，然后再发送下一个请求。管线化技术中，客户端可以连续发送多个请求而不等待服务端的响应，服务端在收到多个请求后，挨个发送响应

![](/images/管线化.png)

### 状态码

服务器通过状态码来表示对客户端请求响应的处理结果，常见的状态码主要有五类，如下图所示：

![](/images/状态码.png)

### 2XX

- 200  OK：客户端请求被正常处理
- 204  No Content：服务器正常处理请求，但是没有内容返回

### 3XX

- 301  Moved Permanently：表示客户端请求的资源已经被分配给新的URI，应该使用新的URI进行访问
- 302  FOUND：资源临时被分到新的URI去了

### 4XX

- 400  Bad Request：表示请求报文中有错误
- 401  Unauthorized：表名请求没有通过HTTP认证
- 403  Forbidden：服务器拒绝客户端对请求资源的访问
- 404  Not Found：服务器上没有请求访问的资源

### 5XX

- 500  Internal Server Error：服务器处理请求时发生错误
- 503  Service Unavailable：表明服务器当前可能停机维护，不能处理请求

### HTTP的优点和缺点

### 优点

- 简单：报文格式就是Header+Body，头部信息也是简单的key-value形式
- 灵活和易扩展：协议中的各种请求方法、URI/URL、状态码、头字段等各个组成部分，允许开发人员自定义和扩充
- 应用广发和跨平台

### 缺点

- 通信使用明文（不加密），内容可能会被窃听
- 不验证通信方的身份，因此有可能遭遇伪装
- 无法验证报文的完整性，所以有可能遭遇篡改
- 无状态传输

## HTTPS协议

HTTP协议是直接和TCP进行通信，而HTTPS则是HTTP先和SSL进行通信，再由SSL和TCP进行通信。简单来说，HTTPS就是披着SSL外衣的HTTP通信   

TLS是在SSL为原型开发的协议，有时统一将它们称为SSL 

![](/images/HTTPS和HTTP.png)

使用了SSL，HTTP就有了加密、证书和完整性保护的功能了

### 对称加密

加密和解密使用同一个密钥的方式叫做对称加密，在发送加密内容时也必须将密钥发送给对方，这样一旦密钥被劫持就可以对加密内容进行解密。

SSL使用就是这种加密方式

### 非对称加密

非对称加密具有两把密钥，公钥可以随意发送，但是私钥只有自己知道。

发送密文的一方，使用对方发送过来的公钥进行加密内容，对方在收到密文之后，使用自己的私钥进行解密。

### HTTPS使用混合加密的方式

非对称加密虽然可以确保信息不会被窃听的风险，但是非对称加密在对内容加密的时候，处理速度非常的慢，没有对称加密那样快，所以先使用非对称加密来加密对称加密的密钥，交换密钥成功之后，再使用对称加密的方式来进行通信。  

![](/images/混合加密.png)

### 数字证书

为了验证公开密钥是安全的，因此客户端和服务端会向数字认证证书机构CA来来申请数字证书签名

### HTTPS的安全通信过程

![](/images/HTTPS安全通信过程.png)

1. 客户端通过发送ClientHELLO报文开始SSL通信，包括客户端支持的SSL版本，所使用的加密组件（加密算法和密钥长度）
2. 服务器收到后，以SEVERHELLO作为回应，同样包含SSL版本和加密组件（和客户端相同）
3. 服务器向客户端发送公开密钥证书
4. 服务器发送SeverHelloDone，表示最初的SSL握手协商结束
5. 客户端向服务器发送Pre-master secret随机密码串，随机密码串已经使用公开密钥进行加密
6. 客户端继续向服务端发送报文，表示之后的内容都会使用随机密码串Pre-master secret进行加密
7. 客户端发送结束报文，这个报文包含至今全部报文的校验值，握手协商是否已经成功，要以服务器是否能够对本次的内容进行成功解密
8. 服务器同样发送ChangeCiperSpec报文，表明已经知道使用Pre-master对内容进行加密
9. 服务器发送Finished报文，至此SSL连接已经建立完成，后续的通信都会受到SSL的保护
10. 客户端向服务器发起请求
11. 服务端向客户端发起响应
12. 客户端发起断开连接请求

在之上的流程中，应用层发送数据时会附加一个MAC（message Authentication Code）的报文摘要，能够用来验证报文是否遭受篡改，保护报文的完整性

### HTTP和HTTPS的区别

- HTTP是明文传输，HTTPS是加密传输、
- HTTP在TCP三次握手之后，就可以进行内容传输，HTTPS还要进行SSL/TLS四次握手
- HTTP的端口号是80，HTTPS是443
- HTTPS需要向CA申请数字证书，来证明服务器的身份是可信的

## HTTP的缺陷和改进

### HTTP/1.1对HTTP/1.0的改进

- 使用TCP长连接
- 支持管道传输

缺陷

- 请求只能从客户端进行发送，客户端不能接受除了响应之外的任何指令
- 请求/响应的首部未经压缩就发送，首部信息越多，延迟就会越大
- 发送冗长的首部，每次都是发送相同的首部造成很大的浪费
- 按照请求的顺序对其进行响应，如果之前的某个请求没有响应，后续的就会堵塞，这就是对头堵塞

### HTTP2对HTTP/1.1的改进

HTTP2是基于HTTPS的，所以其也是加密传输，能够保证数据传输的安全性

- 服务器推送：在HTTP2中服务器也可以主动向客户端推送消息，不再是完全传统的请求相应式工作模式
- 头部压缩：如果客户端同时发送多个请求，这些请求的头部相似或者完全一样，协议就会消除这些重复的部分
- 多路复用：HTTP2可以并发多个请求和响应，不用按顺序对请求进行响应，避免了对头堵塞的问题
- 二进制格式：在HTTP2中数据不再是纯文本的格式，而全面是用二进制编码，报文首部变为头信息帧，报文主体变为数据帧，这样增加了数据传输的效率

HTTP3对HTTP2的改进

HTTP2中多个请求复用一个TCP连接，底层TCP协议并不清楚有多少个请求，一旦发生丢包问题，就会触发TCP的重传机制，这样一个TCP连接中的所有HTTP请求都会等待这个被丢的包重传回来，因此HTTP3将下层的TCP协议变为了UDP协议