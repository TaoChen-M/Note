GCC编译过程：
	预处理、编译、汇编、链接
	gcc test.c -o test
	
TCP UDP的区别：
	1、TCP面向连接，确保数据的可靠传输，基于字节流；UDP无需面向连接，尽最大努力交付，基于报文传输
	2、TCP是一对一的传输，具有流量控制和拥塞控制，主要应用在对数据准确性较高的场景
	3、UDP支持一对一，一对多，最主要的特点就是快，通常应用在很多实时性较高的场景，比如语音通话、视频通话
	
进程间的通信：
	1、管道
	2、消息队列
	3、信号
	4、信号量
	5、共享内存
	6、Socket套接字 
	
线程同步
	1、互斥锁，主要针对共享数据，同一时刻只能够允许一个线程对数据进行修改
	2、信号量，主要包括P操作和V操作
	3、读写锁，同一个临界区可以同时加好几个读锁，但是有且只能有一个写锁，读锁和写锁不能存在同一个临界区
	4、条件变量，主要有wait()和signal()函数，配合互斥锁进行使用
	
引用和指针的区别:
	1、指针中保存的是变量的内存地址了，引用是变量的别名
	2、指针可以为空，但是引用不可以，并且引用在创建的时候就要进行初始化
	3、指针使用时可以进行解引用，引用不需要
	4、指针可以是多级的，引用不可以
	
面向对象编程的三大特性：
	封装、继承、多态
	
什么是多态：
	多态分为静态多态和动态多态；
	静态多态是在编译的时候实现的，主要包括函数重载、运算符重载和泛型编程
	动态多态是在运行时实现，主要利用虚函数来实现：基类的指针指向派生类的对象，这样可以调用派生类中的函数；派生类可以对基类的虚函数进行重写
	
虚函数和纯虚函数：
	有virtual关键字修饰的函数是虚函数
	派生类中可以对基类的虚函数进行重写也可以不重写，但是纯虚函数必须在派生类中进行重写
	纯虚函数：virtual int func=0

构造函数和析构函数能不能是虚函数：
	构造函数不可以是虚函数
	析构函数可以是虚函数，并且基类中的析构函数最好是虚函数，因为这样调用delete操作符销毁指向对象的指针能够准确的调用派生类的析构函数

C++的浅拷贝和深拷贝：
	浅拷贝：只是增加了一个指向相同堆区的指针，两个指针指向同一块内存，这会导致析构的时候重复释放。默认的拷贝构造和运算符重载都是浅拷贝
	深拷贝：是在拷贝的时候将原有内存中复制一份放到一片新申请的内存中去，指针指向这个新内存地址，避免出现重复析构的现象。一般类中有指针的时候需要手动创建拷贝函数

  
